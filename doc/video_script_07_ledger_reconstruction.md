# Tech Demo: 建構金融級「時光機」—— 雙分錄帳本與狀態重構
# (Constructing a Financial Time Machine: Double-Entry Ledger & State Reconstruction)

**總時長預估：** 4 - 6 分鐘
**目標受眾：** 技術面試官、架構師、CTO
**核心展現能力：** 系統架構設計、資料一致性設計、不可變性 (Immutability)、效能優化技巧。

---

## 1. 導言：為什麼「餘額」不應該只是這資料庫裡的一個數字？ (The "Why")

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 0:00 | **[傳統 vs 現代]**<br>左邊：傳統 `UPDATE balance = balance + 100` (打叉)。<br>右邊：Log Append `Event: DEPOSIT 100` (打勾)。<br>字幕：**Auditability (可審計性) & Traceability (可追溯性)**。 | 在設計高可靠的金融系統時，我堅持一個原則：**資料庫裡的「餘額」只是一個緩存，真正的真相在於「流水」**。<br>傳統的直接修改餘額做法，一旦出現數據不一致，我們無法回答「錢去哪了？」。今天我要展示的是，如何在 Open Exchange Core 中實作**雙分錄帳本**，並具備**重構任意歷史時刻資產負債表**的能力——就像給系統裝了一台時光機。 | 開門見山，展現對資料正確性的堅持。 |

---

## 2. 核心機制：雙分錄帳本 (Double-Entry Ledger)

**技術點：** 會計恆等式、事務原子性。

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 0:50 | **[Schema 展示]**<br>展示 `journal_entry` 表結構。<br>重點欄位：`dr_account` (借方), `cr_account` (貸方), `amount`。<br>動畫演示：用戶充值 100 元 -> 用戶資產(+), 平台負債(+)。 | 這是核心的帳務表結構。不同於單純的加減，每一筆交易在我的系統中都是一對「借貸分錄」。<br>例如用戶充值，系統會同時記錄：借記「平台儲備金帳戶」，貸記「用戶錢包帳戶」。這保證了 `Assets = Liabilities + Equity` 的會計恆等式永遠成立。這不僅防止了資金憑空產生或消失，更讓我們能隨時生成平台級別的**資產負債表**，進行自我審計。 | 強調「不只是寫程式，更懂領域知識 (Domain Knowledge)」。 |

---

## 3. 挑戰：如何回到過去？ (The Challenge: Time Travel)

**技術點：** 不可變日誌 (Immutable Logs)、事件溯源 (Event Sourcing) 概念。

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 1:40 | **[情境題]**<br>黑底白字問題：<br>「用戶投訴：昨天下午 2 點我的餘額明明有 5000U，為什麼現在紀錄不對？」<br>資料庫現狀：餘額 2000U。 | 當發生交易糾紛，或者需要進行監管審計時，僅僅知道「現在的餘額」是不夠的。我們需要回答：「在 2023 年 10 月 5 日 14:30:00.000，系統的完整狀態是什麼？」<br>由於我的帳本設計是基於**不可變 (Immutable)** 的流水寫入，這賦予了我們「時光回溯」的能力。 | 提出一個具體的工程難題。 |

---

## 4. 解決方案：快照 + 增量重放 (Snapshot + Delta Replay)

**技術點：** 效能優化、演算法。

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 2:20 | **[架構動畫]**<br>1. **Base Snapshot**: 每天凌晨 0 點的結餘快照。<br>2. **Delta Logs**: 0 點之後的所有流水。<br>3. **Reconstruction**: `Snapshot + Sum(Logs where time <= TargetTime)`。<br>程式碼片段：`calculateBalanceAt(userId, timestamp)`。 | 然而，如果系統運行了三年，我們不可能從第一筆交易開始重跑所有流水，那太慢了。<br>我的解決方案是 **「快照 + 增量重放」** 機制。系統會定期（例如每日或每小時）生成全域的帳務快照 (Checkpoint)。當需要查詢特定時間點的資產負債表時，程式會自動載入**最接近該時間點的前一個快照**，然後從 WAL (Write-Ahead Log) 中讀取該快照之後、目標時間之前的所有流水進行累加。 | 展現對效能 (Performance) 的考量，這是資深工程師的特徵。 |

---

## 5. 實機演示 (Live Demo)

**技術點：** 實際操作證明。

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 3:20 | **[IDE / Terminal 操作]**<br>1. 執行單元測試或 CLI 工具。<br>2. 輸入目標時間：`2023-10-05 T14:30:00`。<br>3. Console 輸出日誌：<br>`> Loading Snapshot (ID: 1050)... Done (5ms)`<br>`> Replaying 342 events... Done (12ms)`<br>`> Result: Balance = 5000.00` | 讓我們看實際演示。這裡有一個測試案例。我將時間設定在昨天下午兩點。系統底層啟動了重構邏輯：它找到了昨天中午 12 點的快照，並快速重放了接下來兩小時內的 300 多筆交易。<br>結果出來了，系統精確地還原了當時的餘額 5000.00，與用戶聲稱的一致。這證明了系統數據的完整性與可驗證性。 | 讓數據說話。 |

---

## 6. 總結與價值 (Conclusion)

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 4:10 | **[架構圖回顧]**<br>關鍵字浮現：<br>**Double-Entry (雙分錄)**<br>**Immutability (不可變性)**<br>**Point-in-Time Recovery (任意時間點恢復)** | 總結來說，透過雙分錄帳本，我們保證了資金流動的**正確性**；透過快照與日誌重放，我們實現了對歷史狀態的**完全掌控**。<br>這套機制不僅能應對極端狀況下的災難恢復 (DR)，更是建立用戶與監管機構信任的基石。這就是我為 Open Exchange Core 構建的金融級後端基礎。 | 總結要強有力，連結到商業價值 (Trust/Reliability)。 |
