# Open Exchange Core - 技術展示系列 Ep.3：核心業務流程與分佈式事務 (Core Workflows & Distributed Transactions)

**總時長預估：** 8 - 10 分鐘
**核心目標：** 展示系統如何在高併發場景下，透過**事件驅動架構 (EDA)** 與**雙分錄帳本 (Double-Entry Ledger)**，在不犧牲效能的前提下實現嚴格的資金一致性。

---

## 1. 開場 (Introduction)

**核心價值：** 點出交易系統最大的挑戰——分佈式環境下的**併發衝突**與**隔離性缺失**。

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 0:00 | **[撮合的不確定性]**<br>動畫：訂單進入黑盒子(撮合引擎)，時間軸拉長。<br>衝突演示：下單時凍結 100 元 -> (等待成交期間) -> 倉位被強平/價格劇烈波動 -> 成交時資源不足/狀態衝突。 | 構建高頻交易核心最棘手的挑戰，其實不在於速度，而在於「撮合」這個動作帶來的**時間不確定性**。<br>當訂單進入撮合引擎後，分佈式事務的完成時間就變得無法預測。從「下單預扣」到「最終成交」，中間可能發生無數變數——用戶的倉位可能被強平、行情可能劇烈波動，導致初始凍結的資源在結算時根本不夠扣，甚至交易順序發生錯亂。<br>在缺乏傳統資料庫全域「隔離性 (Isolation)」的分佈式環境下，我們該如何解決這些致命的**併發衝突**？今天，我們將深入 Open Exchange Core 的心臟，揭示它如何駕馭這種混亂。 | 強調「不確定性」與「衝突」。 |

---

## 2. 訂單生命週期 (The Order Lifecycle)

**核心價值：** 展示系統如何根據「開倉」與「平倉」的不同意圖，智能分流處理邏輯，確保資產與倉位的精確鎖定。

### 2.1 意圖判斷 (Intent Determination)

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 1:00 | **[交易意圖識別]**<br>顯示 API 請求：`BUY 1 BTC`。<br>動畫：查詢 Position Service。<br>分歧路徑：<br>1. 無持倉 -> **OPEN (開倉)**。<br>2. 持有空單 -> **CLOSE (平倉)**。 | 一筆簡單的「買入」訂單，在合約交易中可能代表截然不同的意義：可能是「建立多頭倉位」，也可能是「平掉空頭倉位」。<br>因此，當訂單進入系統時，第一步是呼叫 `Position Service` 進行**意圖判斷**。系統會根據用戶當前的持倉狀態，將訂單標記為 `INCREASE` (開倉) 或 `REDUCE` (平倉)。這個判斷將決定後續截然不同的資金鎖定與結算流程。 | |

### 2.2 開倉流程：資金驅動 (The Open Path: Asset Driven)

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 1:30 | **[開倉：凍結資產]**<br>路徑：Order -> **Account Service**。<br>事件：`FundsFreezeRequested` -> `FundsFrozen`。<br>**[開倉：結算]**<br>事件：`TradeExecuted` -> Account 處理 -> `TradeMarginSettled` -> Position 更新。<br>特寫：手續費退差額 (Fee Refund)。 | 如果判定為 **開倉 (Open)**，核心邏輯是「鎖定資金」。<br>Order Service 會發布事件請求 `Account Service` 凍結用戶錢包中的可用餘額作為初始保證金，這筆金額包含了預收的 Taker 手續費。一旦撮合成交，Account Service 會直接處理成交事件，根據**實際成交張數的比例**精確計算應收手續費，將預收金額中多出的差額自動退還至用戶餘額，並將剩餘凍結資金轉入逐倉保證金帳戶 (Isolated Margin)，最後發布 `TradeMarginSettled` 通知 Position Service 建立或增加倉位。 | |

### 2.3 平倉流程：倉位驅動 (The Close Path: Position Driven)

| 時間   | 畫面 (Visual)                                                                                                                                                                       | 旁白腳本 (Audio)                                                                                                                                                                                                                                          | 執行建議 |
| :--- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--- |
| 2:00 | **[平倉：鎖定持倉]**<br>路徑：Order -> **Position Service**。<br>動作：`reserve(quantity)` 預扣持倉。<br>**[平倉：結算]**<br>事件：`TradeExecuted` -> Position 處理 -> `PositionMarginReleased` -> Account 入帳。 | 相對地，如果判定為 **平倉 (Close)**，核心邏輯則是「鎖定持倉」。<br>系統會直接在 `Position Service` 中預扣可平倉數量，確保用戶不會超額平倉。成交後，結算權轉交給 Position Service：它會計算已實現盈虧 (PnL)，將原本的保證金加上盈虧（可能是負數），打包成 `PositionMarginReleased` 事件發送給 Account Service。Account Service 收到後，僅需執行簡單的入帳操作，將資金釋放回用戶錢包。 |      |

### 2.4 異常與補償 (Failure & Compensation)

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 2:30 | **[回滾機制]**<br>開倉失敗：`FundsFreezeFailed` -> 訂單拒絕。<br>平倉失敗：Matching 撤單 -> 解鎖持倉。<br>文字：**Atomic Rollback**。 | 無論是開倉時餘額不足，還是平倉時持倉不足，系統都設計了嚴格的**原子回滾機制**。開倉鎖定失敗會直接觸發 `FundsFreezeFailed` 事件導致訂單拒絕；而平倉訂單若在撮合前被取消，Order Service 會通知 Position Service 解鎖預扣的持倉數量，確保系統狀態能夠精確恢復到操作前，不留任何髒數據。 | |

### 2.5 高性能撮合 (High-Performance Matching)

| 時間   | 畫面 (Visual)                                                                                                                                                         | 旁白腳本 (Audio)                                                                                                                                                                                                                                                                      | 執行建議            |
| :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------- |
| 2:50 | **[LMAX 架構示意]**<br>單執行緒 (Single Thread) + 內存撮合 (In-Memory)。<br>動畫：訂單進入 RingBuffer，高速撮合。<br>顯示 `MatchResult` 寫入 WAL (Write-Ahead Log)。<br>特寫：Price-Time Priority 算法。 | 進入 `Matching Service` 後，我們採用了 **LMAX 架構風格**。針對每個交易對，我們使用**單執行緒**進行全內存撮合，消除了鎖競爭與 Context Switch 的開銷。在撮合邏輯上，我們嚴格遵循 **價格優先、時間優先 (Price-Time Priority)** 的算法，確保交易的公平性。撮合結果並不直接寫庫，而是先循序寫入本地磁碟的 **WAL (Write-Ahead Log)**。一旦 WAL 落盤成功，即視為業務完成 (Commit Point)，這讓我們的撮合引擎能達到微秒級的延遲與極高的吞吐量。 | 強調「單執行緒」與「WAL」。 |

---

## 3. 分佈式事務與一致性 (Distributed Transactions & Consistency)

**核心價值：** 解釋如何透過 Kafka 與 Outbox 模式，在解耦服務的同時保證數據最終一致。

### 3.1 異步持久化與 Outbox (Async Persistence & Outbox)

| 時間   | 畫面 (Visual)                                                                                                                                    | 旁白腳本 (Audio)                                                                                                                                                                                                                                | 執行建議 |
| :--- | :--------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :--- |
| 3:00 | **[Transactional Outbox]**<br>DB Transaction: [Insert Trade] + [Insert Outbox].<br>CDC: Debezium 讀取 Binlog -> Kafka。<br>動畫：DB -> Kafka 不會丟失訊息。 | 撮合完成後，如何可靠地通知下游服務？我們拒絕了雙寫 (Double Write) 的不可靠模式，而是採用了 **Transactional Outbox** 模式。撮合引擎的 Loader 執行緒會在同一個 DB 事務中，將成交紀錄與 Outbox 事件寫入資料庫。隨後，透過 CDC (Change Data Capture) 技術捕捉 Binlog 變更並推送到 Kafka。這保證了**只要資料庫寫入成功，事件就一定會發送**，實現了 DB 與 MQ 的強一致性。 |      |

### 3.2 冪等性消費 (Idempotent Consumer)

| 時間   | 畫面 (Visual)                                                                                                                               | 旁白腳本 (Audio)                                                                                                                                                    | 執行建議 |
| :--- | :---------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--- |
| 3:40 | **[冪等性防禦]**<br>代碼：`isTradeAlreadyProcessed(tradeId)`。<br>SQL：`INSERT IGNORE` 或 `Version` 檢查。<br>動畫：Kafka 重複發送同一訊息 -> Consumer 偵測重複 -> 丟棄。 | 在分佈式環境中，訊息重複是不可避免的。因此，我們的所有消費者（Account, Position, Order）都實作了嚴格的**冪等性檢查**。透過在資料庫中記錄已處理的 `Trade ID` 或使用樂觀鎖版本號，我們確保了即使同一筆成交事件被 Kafka 重複投遞，系統的資金與狀態也不會發生錯誤的重複扣減或累加。 |      |

---

## 4. 深度解析：雙分錄帳本 (Double-Entry Bookkeeping)

**核心價值：** 展示金融級的記帳邏輯，確保資產負債表永遠平衡。

| 時間   | 畫面 (Visual)                                                                                                                                                                    | 旁白腳本 (Audio)                                                                                                                                                                                                                                                               | 執行建議 |
| :--- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--- |
| 4:20 | **[會計恆等式]**<br>公式：`Asset + Expense = Liability + Equity + Revenue`。<br>顯示 `user_journal` 與 `platform_journal` 表結構。<br>動畫：用戶支付手續費 -> 用戶 Equity 減少，平台 Revenue 增加。 | 在 `Account Service` 中，我們屏棄了簡單的加減餘額，而是採用了銀行級的**雙視角雙分錄 (Dual-View Double-Entry)** 架構。每一次資金變動（如下單凍結、成交結算、手續費扣除），都會同時在「用戶帳本」與「平台總帳」中產生對應的借貸分錄。透過嚴格遵守 `資產 = 負債 + 權益` 的會計恆等式，我們能隨時生成用戶的資產負債表，並進行平台級別的儲備金證明 (PoR) 核對，確保系統沒有任何一分錢憑空產生或消失。 |      |

---

## 5. 複雜場景：倉位反手與結算 (The Flip & Settlement)

**核心價值：** 解決衍生品交易中最複雜的「反手」場景（多單轉空單）。

### 5.1 反手邏輯 (Flip Logic)

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 5:10 | **[Flip 場景動畫]**<br>狀態：持多單 10 張。<br>動作：賣出 15 張。<br>結果：平倉 10 張 -> (資金結算) -> 開空 5 張。<br>顯示 `PositionIntent` 中的 `INCREASE`/`REDUCE` 判斷。<br>特寫：Idempotency Key (`TradeID:FLIP_CLOSE`, `TradeID:FLIP_OPEN`)。 | 合約交易中最棘手的場景莫過於「反手 (Flip)」——例如用戶持有 10 張多單，卻下了一筆賣出 15 張的空單。這筆訂單實際上包含了「平掉 10 張多單」與「新開 5 張空單」兩個原子動作。<br>我們的 `Position Service` 能智慧識別這種意圖，並在收到成交事件時，自動將其拆解。為了確保冪等性，系統會為這兩個拆解後的動作生成獨一無二的鍵值——原 Trade ID 加上 `:FLIP_CLOSE` 與 `:FLIP_OPEN` 後綴。這確保了即便在分佈式重試的情況下，平倉結算與反向開倉也絕不會發生重複執行或數據衝突。 | |

### 5.2 補償機制 (Compensation)

| 時間   | 畫面 (Visual)                                                                                                    | 旁白腳本 (Audio)                                                                                                                                                                                                                          | 執行建議 |
| :--- | :------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :--- |
| 5:50 | **[極端併發處理]**<br>場景：原本想平倉，結果倉位在途中被強平了。<br>處理：`PositionCloseToOpenCompensation` 事件。<br>Ledger 動作：允許餘額暫時為負，標記需補款。 | 但在極端併發下，如果用戶的持倉在反手單成交前就被強平了怎麼辦？這時，原本的「平倉單」會變成無倉可平的「無效平倉」。<br>為了處理這種 Race Condition，我們設計了**補償機制**：系統會將這筆異常成交視為「強制開倉」，並發送 `PositionCloseToOpenCompensation` 事件給帳務系統。帳務系統會直接執行扣款，若餘額不足則允許帳戶暫時呈現負值並標記追繳，確保了交易數據的完整性與可追溯性，絕不因為併發錯誤而丟失成交紀錄。 |      |

---

## 6. 總結 (Conclusion)

| 時間   | 畫面 (Visual)                                                                                                  | 旁白腳本 (Audio)                                                                                                                                                                                                    | 執行建議 |
| :--- | :----------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--- |
| 6:30 | **[架構全景回顧]**<br>Gateway -> Auth -> Order -> Matching -> Account/Position。<br>文字浮現：**Speed, Accuracy, Resilience**。 | 回顧整個流程：從下單時的風控預檢、撮合引擎的極速寫入，到異步的雙分錄結算與冪等性處理。Open Exchange Core 透過精密的事件編排與嚴謹的帳務設計，在分佈式架構下成功實現了金融級的數據一致性。這不僅是一套高效的交易系統，更是一座值得信賴的數位資產堡壘。 |      |
