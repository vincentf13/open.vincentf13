# 影片腳本：撮合引擎核心 - WAL 與 Snapshot 災難恢復測試

## 影片資訊
- **主題**：金融級高可靠性系統測試 - 撮合引擎的時光機
- **目標觀眾**：後端工程師、架構師、QA 工程師
- **核心概念**：Test Design in AI Era, Integration Testing, Disaster Recovery, Order Book Structure

---

## 投影片 (PPT) 與 口白腳本 (Script)

### Slide 1: AI 時代的工程師核心能力
**[視覺呈現]**
- 標題：高可靠性系統的工程支柱：正確性、不變性與測試設計
- 中央圖示：天平兩端。
    - 左端：**複雜場景下的正確性與不變性設計** (Engineering for Determinism & Immutability)
    - 右端：**高品質的測試設計能力** (Test Design & Verification Capability)
- 底部文字：「AI 負責生成實現，工程師負責定義正確。」
- 側邊：測試光譜 (Integration, Concurrency, Security, Load Testing)。

**[講者口白]**
大家好！在 AI 輔助開發的今天，寫程式碼的門檻已經大幅降低。但這也引發了一個關鍵問題：身為資深工程師，我們不可取代的價值在哪裡？

我認為有兩大能力是目前最重要的：
第一，是**在複雜場景下，確保系統核心「正確性」與「不變性」的整合設計能力**。特別是在金融系統中，我們需要透過精密的架構設計，確保核心邏輯在各種極端變動下，依然保持預期中的行為。
第二，是**高品質的「測試設計能力」**。

AI 寫代碼很快，但它不知道在哪個邊界會導致數值溢位，也不知道在哪個極端場景會導致數據丟失。唯有具備嚴謹測試設計能力的人，才能定義什麼是「正確」。

今天我們要實作的 `WalRecoveryTest`，正是這兩大能力的結合。它屬於**「高可靠性整合測試」**，目標是確保撮合引擎在任何災難重啟後，都能保持資產狀態的絕對不變與正確。這也是我們今天影片的核心重點。

---

### Slide 2: 撮合引擎架構：從 Processor 到 Order Book
**[視覺呈現]**
- 架構圖：由外而內，層層放大。
    1.  **Matching Engine (Service)**：整個撮合服務。
    2.  **InstrumentProcessor (Component)**：圖中核心，連接著 `Wal`, `Snapshot`, `OrderBook`。
    3.  **OrderBook (Data Structure)**：
        - `bids`: `TreeMap` (降序) -> 買方：價高優先
        - `asks`: `TreeMap` (升序) -> 賣方：價低優先
        - `Deque`: 時間優先 (FIFO)

**[講者口白]**
讓我們來看看這次的測試對象。
整個撮合引擎的核心，是由 **`InstrumentProcessor`** 來驅動的。它就像是一個指揮官，負責協調三個關鍵組件：
1.  **InstrumentWal**：負責將每一筆操作寫入日誌 (Log)，確保數據不丟失。
2.  **InstrumentSnapshot**：負責定期將記憶體狀態存檔 (Checkpoint)。
3.  **OrderBook**：負責實際的訂單撮合邏輯。

我們選擇 **`InstrumentProcessor`** 作為測試切入點，而不是直接測 `OrderBook`，因為這樣才能完整驗證「記憶體撮合」與「持久化機制」之間的協作是否正確。

至於最底層的 **Order Book (訂單簿)**，我們使用了 Java 的 `TreeMap` 來儲存價格檔位。
- 對於**買單**，我們用降序排列，出價最高者優先。
- 對於**賣單**，我們用升序排列，賣最便宜者優先。
- 同價格下，則用 `Deque` 保證先進先出。

---

### Slide 3: 測試場景設計 (Scenario Design)
**[視覺呈現]**
- 流程圖：
    1.  **Phase 1: Normal Operation** -> 寫入 1000 筆訂單 (觸發 Snapshot) -> 寫入 2 筆 WAL 訂單 (涵蓋買賣與邊界值)。
    2.  **Phase 2: System Crash** -> 模擬 `shutdown()`。
    3.  **Phase 3: Recovery** -> 新的 Processor `init()` -> 載入 Snapshot -> 重放 WAL。
    4.  **Phase 4: Validation** -> 驗證 1002 筆訂單狀態 -> 驗證冪等性 -> 驗證新業務撮合。

**[講者口白]**
為了證明系統的強健性，我們設計了一個嚴苛的劇本：

首先是**正常運作階段**：我們注入 1000 筆訂單觸發系統自動生成 Snapshot，接著再追加 2 筆訂單寫入 WAL。這裡我們特意設計了包含小數點後 3 位的價格，以及極大與極小的數量邊界值，確保序列化機制沒有精度丟失。

接著，我們模擬**系統崩潰**，強制關閉處理器。

然後是**重啟恢復**：系統必須自動讀取 Snapshot，並精確地重放 WAL 中最後那 2 筆訂單。

最後進入**驗證階段**：我們不僅檢查訂單數量，還會進行「全量深度比對」，確保每一筆訂單的價格、數量、狀態都分毫不差。

---

### Slide 4: 冪等性與活體檢測 (Idempotency & Liveness)
**[視覺呈現]**
- **Idempotency (冪等性)**:
    - 圖示：重複輸入 WAL Log -> 系統狀態不變 (State Unchanged)。
- **Liveness (活體檢測)**:
    - 圖示：發送 Taker 賣單 -> 系統準確移除最高價買單 (Best Bid ID=999) -> 剩餘 1001 筆訂單。

**[講者口白]**
除了資料還原，我們還驗證了兩個重要特性：

第一是**冪等性 (Idempotency)**：當系統重啟時，可能會重複讀取到相同的 WAL 日誌。我們測試了重複輸入同一批 WAL 訂單，結果證實系統狀態完全沒有改變，這防止了重複扣款或重複下單的嚴重 Bug。

第二是**活體檢測 (Liveness)**：系統恢復後是不是「活」的？我們抓取了當前最高價的買單 (ID 999)，並發送一筆對應的賣單。測試結果顯示，撮合引擎精準地成交並移除了這筆訂單，而其他 1001 筆訂單則完好無損。這證明了我們的 `OrderBook` 排序邏輯在經歷序列化與反序列化後，依然保持正確的優先級。

---

### Slide 5: 總結
**[視覺呈現]**
- Checklist 打勾：
    - [x] 資料持久化 (Persistence)
    - [x] 災難恢復 (Recovery)
    - [x] 數值精度 (High Precision)
    - [x] 冪等性 (Idempotency)
    - [x] 撮合邏輯連續性 (Consistency)

**[講者口白]**
透過這次的 `WalRecoveryTest`，我們不只驗證了程式碼，更建立了一套保障資產安全的機制。從底層的 `TreeMap` 排序修正，到上層的 `Jackson` 序列化配置，每一個環節都經過了嚴格的邊界測試。

在 AI 時代，代碼可以快速生成，但「可靠性」必須由我們透過設計精良的測試來守護。這就是我們如何打造一個讓人睡得著覺的撮合引擎。謝謝大家！