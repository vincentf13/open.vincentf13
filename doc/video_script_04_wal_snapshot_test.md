# 影片腳本：撮合引擎核心 - WAL 與 Snapshot 災難恢復測試

## 影片資訊
- **主題**：高可靠性系統的工程支柱：正確性、不變性與測試設計 - 以 WAL 高可靠性整合測試為例
- **目標觀眾**：後端工程師、架構師、QA 工程師
- **核心概念**：Test Design in AI Era, Integration Testing, Disaster Recovery, Order Book Structure

---

## 投影片 (PPT) 與 口白腳本 (Script)

### Slide 1: AI 時代的工程師核心能力
**[視覺呈現]**
- 標題：高可靠性系統的工程支柱：正確性、不變性與測試設計
- 中央圖示：天平兩端。
    - 左端：**複雜場景下的正確性與不變性設計** (Engineering for Determinism & Immutability)
    - 右端：**高品質的測試設計能力** (Test Design & Verification Capability)
- 底部文字：「AI 加速代碼實現，工程師駕馭複雜場景的設計與整合。」
- 側邊：測試光譜 (Integration, Concurrency, Security, Load Testing)。

**[講者口白]**
大家好！在 AI 輔助開發的今天，寫程式碼的門檻已經大幅降低。但這也引發了一個關鍵問題：身為資深工程師，我們不可取代的價值在哪裡？

我認為有兩大能力是目前最重要的：
第一，是**在複雜場景下，確保系統核心「正確性」與「不變性」的整合設計能力**。特別是在金融系統中，我們需要透過精密的架構設計，確保核心邏輯在各種極端變動下，依然保持預期中的行為。
第二，是**高品質的「測試設計能力」**。

AI 寫代碼很快，但它難以預判在**分散式高流量場景**下，微妙的時序差異會如何引發**競態條件 (Race Conditions)**，也無法預知**節點故障**時的狀態一致性挑戰。唯有具備嚴謹測試設計能力的人，才能在這些複雜維度中定義什麼是「正確」。

因此，我們需要建立完整的**測試光譜**來確保系統的韌性與完整性。這包含：
1. **壓力測試 (Load Test)**：驗證在高併發流量下的吞吐量與延遲。
2. **並行測試 (Concurrency Test)**：捕捉極限狀態下的執行緒安全問題。
3. **安全測試 (Security Test)**：建立防禦縱深，例如防範時序旁路攻擊 (Timing Side-Channels) 與交易重放 (Replay Attacks)。
以及我們今天的主角：
4. **整合測試 (Integration Test)**：驗證各組件在真實持久化流程中的協作正確性。

今天我們要實作的 `WalRecoveryTest`，正是屬於這光譜中的**「高可靠性整合測試」**。目標是確保撮合引擎在任何災難重啟後，都能保持資產狀態的絕對不變與正確。這也是我們今天影片的核心重點。

---

### Slide 2: 測試目標與核心架構
**[視覺呈現]**
- 標題：為什麼要測試 WAL 與 Snapshot？從架構看數據流
- 左側：**測試目標 (The Goal)**
    - **RPO = 0 (Recovery Point Objective)**：數據零遺失。
    - **RTO < 秒級 (Recovery Time Objective)**：快速重啟恢復。
- 右側：**核心架構 (The Core)**
    - **InstrumentProcessor** (中央樞紐)
        - ↙️ **OrderBook** (記憶體撮合)
        - ⬆️ **InstrumentWal** (Append-only Log)
        - ↘️ **InstrumentSnapshot** (Checkpoint)

**[講者口白]**
在揭曉詳細的測試計畫前，我們先來談談這次測試的**戰略目標**。
我們為什麼要花這麼大力氣測試 WAL (預寫日誌) 和 Snapshot (快照)？
因為在金融交易中，我們的目標是 **RPO 等於零**。也就是說，即便系統在任何一毫秒斷電，我們也不能遺失使用者的任何一筆掛單或成交紀錄。

為了達成這個目標，我們必須從整體架構了解數據是如何流動的。
首先，在最外層是我們的 **`MatchEngine` (撮合引擎服務)**，它負責接收來自網關的交易指令。
往下深入，針對每一個交易對 (如 BTC/USDT)，我們都有一個獨立的 **`InstrumentProcessor`**。
它是整個引擎的心臟，負責協調三個關鍵動作的原子性：
1.  **日誌 (Write)**：將原始指令寫入 `Wal`，這是我們還原真相的最後手段。
2.  **撮合 (Process)**：在記憶體的 **`OrderBook`** 中進行高速運算。
3.  **存檔 (Checkpoint)**：定期將狀態寫入 `Snapshot`，加速重啟時間。

**這裡的執行流程至關重要**：
當一筆訂單進來時，我們採用 **「WAL First」** 策略。
1.  首先，訂單先要預匹配撮合結果，但是先不執行
2.  接著**同步寫入 (fsync)** 到 WAL 檔案。
3.  確認落地後，才更新記憶體中的 `OrderBook` 狀態。在 `OrderBook` 的內部，我們使用了紅黑樹 (TreeMap) 來管理訂單的價格優先級。
4.  最後，當累積了一定數量的操作後（例如每 1000 筆），Processor 才會觸發一次異步的 **Snapshot**，將當前的記憶體全貌傾印到磁碟。

這種設計確保了：即使在 Snapshot 生成的間隙當機，我們也能透過重放 WAL 來補足最後一段的數據。

我們今天的測試切入點，就是針對這個 **Processor** 進行全流程整合測試，驗證這三者在極端崩潰場景下，是否還能完美協作。

---

### Slide 3: 測試場景設計 (Scenario Design)
**[視覺呈現]**
- 流程圖：
    1.  **Phase 1: Normal Operation** -> 寫入 1000 筆訂單 (觸發 Snapshot) -> 寫入 2 筆 WAL 訂單 (涵蓋買賣與邊界值)。
    2.  **Phase 2: System Crash** -> 模擬 `shutdown()`。
    3.  **Phase 3: Recovery** -> 新的 Processor `init()` -> 載入 Snapshot -> 重放 WAL。
    4.  **Phase 4: Validation** -> 驗證 1002 筆訂單狀態 -> 驗證冪等性 -> 驗證新業務撮合。

**[講者口白]**
為了證明系統的強健性，我們設計了一個嚴苛的劇本：

首先是**正常運作階段**：我們注入 1000 筆訂單觸發系統自動生成 Snapshot，接著再追加 2 筆訂單寫入 WAL。這裡我們特意設計了包含小數點後 3 位的價格，以及極大與極小的數量邊界值，確保序列化機制沒有精度丟失。

接著，我們模擬**系統崩潰**，強制關閉處理器。

然後是**重啟恢復**：系統必須自動讀取 Snapshot，並精確地重放 WAL 中最後那 2 筆訂單。

最後進入**驗證階段**：我們不僅檢查訂單數量，還會進行「全量深度比對」，確保每一筆訂單的價格、數量、狀態都分毫不差。

---

### Slide 4: 冪等性與活體檢測 (Idempotency & Liveness)
**[視覺呈現]**
- **Idempotency (冪等性)**:
    - 圖示：重複輸入 WAL Log -> 系統狀態不變 (State Unchanged)。
- **Liveness (活體檢測)**:
    - 圖示：發送 Taker 賣單 -> 系統準確移除最高價買單 (Best Bid ID=999) -> 剩餘 1001 筆訂單。

**[講者口白]**
除了資料還原，我們還驗證了兩個重要特性：

第一是**冪等性 (Idempotency)**：當系統重啟時，可能會重複讀取到相同的 WAL 日誌。我們測試了重複輸入同一批 WAL 訂單，結果證實系統狀態完全沒有改變，這防止了重複扣款或重複下單的嚴重 Bug。

第二是**活體檢測 (Liveness)**：系統恢復後是不是「活」的？我們抓取了當前最高價的買單 (ID 999)，並發送一筆對應的賣單。測試結果顯示，撮合引擎精準地成交並移除了這筆訂單，而其他 1001 筆訂單則完好無損。這證明了我們的 `OrderBook` 排序邏輯在經歷序列化與反序列化後，依然保持正確的優先級。

---

### Slide 5: 總結
**[視覺呈現]**
- Checklist 打勾：
    - [x] 資料持久化 (Persistence)
    - [x] 災難恢復 (Recovery)
    - [x] 數值精度 (High Precision)
    - [x] 冪等性 (Idempotency)
    - [x] 撮合邏輯連續性 (Consistency)

**[講者口白]**
透過這次的 `WalRecoveryTest`，我們不只驗證了程式碼，更建立了一套保障資產安全的機制。從底層的 `TreeMap` 排序修正，到上層的 `Jackson` 序列化配置，每一個環節都經過了嚴格的邊界測試。

在 AI 時代，代碼可以快速生成，但「可靠性」必須由我們透過設計精良的測試來守護。這就是我們如何打造一個讓人睡得著覺的撮合引擎。謝謝大家！