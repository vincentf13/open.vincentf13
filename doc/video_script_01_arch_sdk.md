# Open Exchange Core - 技術展示系列 Ep.1：系統架構與 SDK 設計

**影片長度：** 約 3 分鐘
**核心亮點：** LMAX 架構、事件驅動 (EDA)、全內存撮合、橫向擴展

---

## 1. 系統架構總覽 (System Architecture Overview)

**目標：** 深入剖析為何傳統架構無法支撐金融級高頻交易，並展示 Open Exchange Core 如何透過架構創新解決此問題。

| 時間   | 畫面 (Visual)                                                                                                                                                                                      | 旁白腳本 (Audio)                                                                                                                                         | 執行建議                   |
| :--- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------- |
| 0:00 | **[對比動畫：傳統 vs 現代]**<br>左邊顯示「傳統架構」：大量請求擠向一個 Database 圖示，DB 出現紅色鎖頭 (Lock)，請求排隊阻塞。<br>右邊顯示「Open Exchange Core」：數據像流水一樣通過管道 (Kafka)，毫無阻礙。                                                            | 傳統金融系統往往受限於資料庫的 ACID 鎖機制 (Locking)。當成千上萬筆訂單同時湧入時，資料庫的行級鎖會導致嚴重的資源競爭。Open Exchange Core 徹底摒棄了這種依賴，採用了**全異步的事件驅動架構 (Event-Driven Architecture)**。       | 先點出「DB Locking」這個反派角色。 |
| 0:25 | **[架構特寫：LMAX 核心思想]**<br>畫面顯示一個類似 CPU 管道的圖示。<br>標註：**Disruptor Pattern / Ring Buffer**。<br>數據單向流動，無鎖競爭。                                                                                           | 我們借鑒了 **LMAX Disruptor** 的架構思想。雖然為了資料安全性，我們在訂單入口處仍會進行持久化，但在最核心的**撮合與定序 (Sequencing)** 環節，我們完全移除了磁碟 I/O 與鎖競爭。                                         | 點出 LMAX 與 Disruptor。   |
| 0:45 | **[微觀機制：單執行緒與內存]**<br>鏡頭深入 CPU 內部視角。<br>左邊：多執行緒 (Multi-thread) 互相搶奪 CPU，頻繁出現 Context Switch (紅色閃爍)。<br>右邊：**單一執行緒 (Single-Thread)** 獨佔 CPU 核心，處理一條長長的佇列 (Queue)。<br>字幕：**Microsecond Matching**。 | 透過**單執行緒模型 (Single-Threaded Model)** 與**全內存運算 (In-Memory Computing)**，撮合引擎不再有 Context Switch 的損耗。這使得核心撮合的處理延遲，從傳統的毫秒級，被壓縮到了**微秒 (Microseconds)** 級別。 | 精確區分：撮合是微秒級。           |
| 1:10 | **[彈性擴展演示：分片 (Sharding)]**<br>畫面顯示 `Matching Engine`。<br>當 BTC 流量爆發時，系統自動將 `BTC-USDT` 的處理器分配給獨立的 CPU Core，而 `ETH-USDT` 則在另一個 Core 運行。<br>Gateway 則像無狀態服務一樣隨意複製。                                  | 這種架構同時帶來了極致的**橫向擴展性**。Gateway 作為無狀態服務可以無限水平擴展；而有狀態的撮合引擎，則透過**交易對分片 (Sharding)** 實現資源隔離。某個熱門幣種的流量爆發，絕不會拖累整個交易所的運行。                                    | 解釋擴展性的原理。              |

---

## 2. SDK 設計與架構治理 (SDK Design & Governance)

**目標：** 展示在如此高效但複雜的架構下，如何透過標準化手段降低開發難度。

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 1:40 | **[IDE 專案結構特寫]**<br>展開 `sdk` 目錄，快速掃過：<br>- `sdk-infra-kafka`<br>- `sdk-core`<br>- `sdk-auth`<br>背景淡出架構圖，聚焦代碼。 | 極致的效能往往伴隨著極高的複雜度。為了駕馭這套架構，我開發了一套標準化的 SDK，封裝了所有的底層細節。 | |
| 1:55 | **[程式碼展示：Spring Boot Starter]**<br>左側：業務邏輯代碼，乾淨簡單。<br>右側：SDK 內的 `KafkaAutoConfiguration`，顯示複雜的序列化、批量發送、冪等性檢查邏輯。 | 透過 Spring Boot Starter 機制，開發者只需要引入依賴，就能獲得經過調優的 Kafka 配置、Redis 連接池以及分佈式鎖實現。這確保了每一行業務代碼，都運行在最優的基礎設施之上。 | |
| 2:15 | **[視覺化效益：全鏈路追蹤]**<br>畫面顯示 Log：`[TraceId: xxxxx]`。<br>切換到 Zipkin/Grafana，顯示一條橫跨 Gateway -> Matching -> Risk 的完整調用鏈，時間軸精確到微秒。 | 同時，SDK 內建了全鏈路可觀測性。從用戶下單的那一刻起，唯一的 Trace ID 就貫穿了整個分佈式系統，讓我們能精確追蹤每一筆資金在微秒間的流動軌跡。 | |

---

## 3. 總結 (Wrap-up)

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 2:35 | **[回到全景架構圖 + 關鍵字]**<br>文字依序浮現：<br>1. **LMAX Architecture**<br>2. **In-Memory Matching**<br>3. **Elastic Sharding** | Open Exchange Core 的架構哲學很簡單：透過 LMAX 思想消除鎖競爭，透過內存計算極大化效能，透過分片設計實現無限擴展。這是一個為速度與規模而生的金融核心。 | |

---

## 準備工作清單 (Action Items)

1.  **動畫概念**：
    *   **LMAX/RingBuffer**: 搜尋 "LMAX Disruptor Architecture diagram" 作為參考，畫一個環形緩衝區的示意圖。
    *   **Sharding**: 用不同顏色的方塊代表不同幣種（BTC, ETH），顯示它們被分配到不同的「跑道」（執行緒/CPU）上互不干擾。
2.  **話術修飾**：
    *   錄音時，強調「撮合環節」是微秒級，這是技術正確的說法，避免被 challenge 整體延遲。