# Open Exchange Core - 技術展示系列 Ep.1：系統架構與 SDK 設計

**影片長度：** 約 3 - 3.5 分鐘
**核心亮點：** LMAX 架構、WAL (預寫式日誌)、Raft 協議、全內存撮合、橫向擴展

---

## 1. 系統架構總覽 (System Architecture Overview)

**目標：** 深入剖析為何傳統架構無法支撐金融級高頻交易，並展示 Open Exchange Core 如何透過架構創新解決此問題。

| 時間   | 畫面 (Visual)                                                                                                                                                                                                     | 旁白腳本 (Audio)                                                                                                                                                                                                             | 執行建議                                     |
| :--- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------- |
| 0:00 | **[對比動畫：傳統 vs 現代]**<br>左邊顯示「傳統架構」：大量請求擠向一個 Database 圖示，DB 出現紅色鎖頭 (Lock)。<br>右邊顯示「Open Exchange Core」：數據像流水一樣通過管道 (Kafka)。                                                                                       | 傳統金融系統往往受限於資料庫的 ACID 鎖機制。當海量訂單湧入時，行級鎖會導致嚴重的資源競爭。Open Exchange Core 徹底摒棄了這種依賴，採用了**全異步的事件驅動架構**。                                                                                                                          |                                          |
| 0:25 | **[架構特寫：LMAX 核心思想]**<br>畫面顯示一個類似 CPU 管道的圖示。<br>標註：**Disruptor Pattern / Ring Buffer**。<br>數據單向流動，無鎖競爭。                                                                                                          | 我們借鑒了 **LMAX Disruptor** 的架構思想。在最核心的撮合環節，我們完全移除了隨機磁碟 I/O 與鎖競爭，採用內存佇列進行定序。                                                                                                                                                |                                          |
| 0:40 | **[深度解析：WAL 與災難復原]**<br>畫面顯示一個 **File** 圖示，數據以 **Batch** 的形式快速寫入。<br>標註：**Sequential Write (順序寫)**。<br>然後演示系統崩潰 (Crash)，接著進度條快速跑動 (Replay)，內存狀態瞬間恢復。<br>右下角浮現未來規劃：**Raft Consensus / RingBuffer Optimization**。 | 為了確保數據絕對安全，我們實現了 **WAL (Write-Ahead Logging)** 機制。所有的撮合事件會先進行**批次順序寫入**——這也是整個撮合過程中**唯一的一次磁碟 I/O**。即使系統瞬間斷電，我們也能透過重放 WAL 日誌，在毫秒級內完全恢復內存狀態。<br>此外，未來也規劃了基於 **Raft 協議** 的事件複製與 **RingBuffer** 優化，進一步提升事件層級的高可用性以及事件發布的即時性。 | **(新增重點)** 批次寫、單次 IO、Raft/RingBuffer 規劃。 |
| 1:10 | **[微觀機制：單執行緒與內存]**<br>鏡頭深入 CPU 內部視角。<br>右邊：**單一執行緒 (Single-Thread)** 獨佔 CPU 核心，處理一條長長的佇列 (Queue)。<br>字幕：**Microsecond Matching**。                                                                               | 透過**單執行緒模型**與**全內存運算**，撮合引擎不再有 Context Switch 的損耗。這使得核心撮合的處理延遲，從傳統的毫秒級，被壓縮到了**微秒 (Microseconds)** 級別。                                                                                                                    |                                          |
| 1:30 | **[彈性擴展演示：分片 (Sharding)]**<br>畫面顯示 `Matching Engine`。<br>當 BTC 流量爆發時，系統自動將 `BTC` 與 `ETH` 分配給不同的 CPU Core 處理。<br>Gateway 則像無狀態服務一樣隨意複製。                                                                          | 這種架構同時帶來了極致的**橫向擴展性**。Gateway 作為無狀態服務可以無限水平擴展；而有狀態的撮合引擎，則透過**交易對分片 (Sharding)** 實現資源隔離。某個熱門幣種的流量爆發，絕不會拖累整個交易所的運行。                                                                                                        |                                          |

---

## 2. SDK 設計與架構治理 (SDK Design & Governance)

**目標：** 展示在如此高效但複雜的架構下，如何透過標準化手段降低開發難度。

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 2:00 | **[IDE 專案結構特寫]**<br>展開 `sdk` 目錄，快速掃過：<br>- `sdk-infra-kafka`<br>- `sdk-core`<br>- `sdk-auth`<br>背景淡出架構圖，聚焦代碼。 | 極致的效能往往伴隨著極高的複雜度。為了駕馭這套架構，我開發了一套標準化的 SDK，封裝了所有的底層細節。 | |
| 2:15 | **[程式碼展示：Spring Boot Starter]**<br>左側：業務邏輯代碼，乾淨簡單。<br>右側：SDK 內的 `KafkaAutoConfiguration`，顯示複雜的序列化、批量發送、冪等性檢查邏輯。 | 透過 Spring Boot Starter 機制，開發者只需要引入依賴，就能獲得經過調優的 Kafka 配置、Redis 連接池以及分佈式鎖實現。這確保了每一行業務代碼，都運行在最優的基礎設施之上。 | |
| 2:35 | **[視覺化效益：全鏈路追蹤]**<br>畫面顯示 Log：`[TraceId: xxxxx]`。<br>切換到 Zipkin/Grafana，顯示一條橫跨 Gateway -> Matching -> Risk 的完整調用鏈，時間軸精確到微秒。 | 同時，SDK 內建了全鏈路可觀測性。從用戶下單的那一刻起，唯一的 Trace ID 就貫穿了整個分佈式系統，讓我們能精確追蹤每一筆資金在微秒間的流動軌跡。 | |

---

## 3. 總結 (Wrap-up)

| 時間 | 畫面 (Visual) | 旁白腳本 (Audio) | 執行建議 |
| :--- | :--- | :--- | :--- |
| 2:55 | **[回到全景架構圖 + 關鍵字]**<br>文字依序浮現：<br>1. **LMAX Architecture**<br>2. **WAL & Raft**<br>3. **Elastic Sharding** | Open Exchange Core 的架構哲學很簡單：透過 LMAX 與 WAL 確保速度與安全，透過分片設計實現無限擴展。這是一個為速度與規模而生的金融核心。 | |

---

## 準備工作清單 (Action Items)

1.  **動畫細節**：
    *   **Sequential Write**: 畫一個硬碟讀寫頭，如果是隨機寫（Random），讀寫頭會瘋狂跳動；如果是順序寫（Sequential），讀寫頭平滑移動。這是很經典的效能對比。
    *   **Crash & Replay**: 可以用「時間倒流」或「快速快轉」的特效來表達 WAL 重放的過程。
2.  **技術關鍵字**：
    *   影片中可以打出 **"Batch IO"**, **"Sequential Access"**, **"Event Sourcing"** 這些專業術語。
