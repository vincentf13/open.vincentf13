# 業務概述

- 系統聚焦永續合約／保證金交易場景，涵蓋下單、撮合、資金結算、倉位管理與行情播送。
- 模組間透過事件流串接，確保下單→撮合→結算→倉位更新的閉環。
- Gateway 承接使用者流量與邏輯入口，風控服務負責同步檢查，撮合與賬本服務確保資產安全與一致性。

# 目錄結構

```
open.vincentf13/
├─ sdk/                          # 共用 SDK 與基礎建設模組聚合
│  ├─ sdk-core/                         # 核心工具、共用常數、標準配置與指標預設
│  ├─ sdk-core-log/                     # 統一 Logback/Log4j2 設定與攔截
│  ├─ sdk-core-test/                    # 測試共用工具、測試容器輔助類別
│  ├─ sdk-spring-mvc/                   # REST 回應包裝、MVC 攔截與設定
│  ├─ sdk-auth/                         # 安全基座：統一 SecurityConfig、審計入口、@PublicAPI/@PrivateAPI/@Jwt/@Session 權限註解，並自動佈署 JWT 與 API Key 過濾器（含順序協調）
│  ├─ sdk-spring-session/               # Spring Session 與 Redis 會話整合
│  ├─ sdk-spring-cloud-gateway/         # Gateway Filter 與路由策略範本
│  ├─ sdk-spring-websocket/             # WebSocket/STOMP 通道設定
│  ├─ sdk-spring-cloud-openfeign/       # Feign 客戶端預設攔截器與容錯
│  ├─ sdk-spring-cloud-alibaba-nacos/   # Nacos 註冊中心、設定中心整合
│  ├─ sdk-infra-mysql/                  # MySQL 動態資料源、MyBatis 自動配置
│  ├─ sdk-infra-redis/                  # Redis 連線池、序列化與鎖工具
│  ├─ sdk-infra-kafka/                  # Kafka Producer/Consumer 統一設定
│  ├─ sdk-library-resilience4j/         # Resilience4j Circuit/Retry/RateLimiter
│  ├─ sdk-auth-jwt/                     # JWT 驗證/解析 Filter、OpenJwtUser、Session 查詢協定與 Token 工具；涵蓋 Claim 標準化與金鑰輪換
│  └─ sdk-auth-server/                  # 基於 sdk-auth 擴充登入/登出/刷新流程，包裝 JWT 生成、Session 管理與審計事件發佈
├─ sdk-contract/                        # API 契約與客戶端聚合
│  └─ exchange-sdk/                     # 交易域專用契約與客戶端聚合
│      ├─ exchange-user-sdk/            # 使用者子模組（REST 契約與客戶端）
│      │   ├─ rest-api/                 # OpenAPI 契約、DTO、Controller 介面（含 UserStatus 等共用枚舉）
│      │   └─ rest-client/              # 依契約生成的 Feign/HTTP 客戶端
│      │       └─ ExchangeUserClient.java # 基於 UserApi 的 FeignClient，透過 sdk-spring-cloud-openfeign 共用攔截與錯誤處理
│      └─ exchange-auth-sdk/            # 認證子模組（REST 契約與客戶端）
│          ├─ rest-api/                 # AuthCredentialApi + DTO（AuthCredentialType 等）
│          └─ rest-client/              # ExchangeAuthClient 封裝 Feign 調用
└─ services/                            # 具體業務服務
   ├─ pom.xml                           # 聚合子服務，統一打包
   ├─ service-user/                     # 使用者域服務
   │   ├─ domain/                       # 聚合根、領域服務、錯誤碼
   │   │   ├─ model/                    # Domain Model (Aggregate / Value Object)
   │   │   │   ├─ User.java                  # 使用者實體（目前為單表主檔，提供狀態判斷）
   │   │   │   ├─ UserErrorCode.java         # 使用者領域錯誤碼
   │   │   │   └─ (Enum via contract)        # UserStatus 等共用枚舉由 sdk-contract 契約提供
   │   │   └─ service/                  # Domain Service 協調領域規則
   │   │       └─ UserDomainService.java    # 領域服務：集中業務不變性（例：註冊時正規化 Email、驗證憑證唯一性）
   │   │                                     # Stateless，避免 @Transactional；由 Application Service 傳入聚合與外部資料
   │   │                                     # 典型場景：變更使用者狀態前先調用風控規則，再委派給聚合執行狀態切換
   │   ├─ infra/                        # Repository / Mapper / PO（資料庫表對應）
   │   │   └─ persistence/              # 持久層實作（Mapper + Repository）
   │   │       ├─ mapper/UserMapper.java     # MyBatis Mapper 介面，依靠全域 camelCase 與 Enum TypeHandler 自動對應欄位
│  │   │       │                             # MyBatis XML 建議優先使用共用模板：insertSelective、updateSelective、findByPO、batchInsert、batchUpdate(<foreach>)
   │   │       ├─ po/UserPO.java             # 資料庫表映射物件，欄位與 users 表一一對應
   │   │       └─ repository/                # Repository 介面集合，返回 Domain 實體
   │   │           └─ UserRepository.java             # 使用者主檔存取介面
   │   │               └─ UserRepositoryImpl.java     # 透過 OpenMapstruct 完成 UserPO ↔ User 轉換
   │   │                                              # 優先使用 insertSelective / updateSelective / findBy(PO) / batchInsert / batchUpdate 模板
   │   │                                              # findOne 以結果筆數驗證單一使用者，保持 @Transactional 邊界由上層控制
   │   ├─ service/                      # Application Service（用例編排，DTO 與 Entity 映射）
   │   │   └─ UserService.java          # Application Service：用例入口，包裝 @Service + @Transactional 邊界
   │   │                                # 將 REST DTO 轉為 Domain Command，調用 Repository/Domain Service，處理事件發布
   │   │                                # 典型場景：registerUser() 內建立交易型 @Transactional，先查重 → 執行 Domain 規則 → 持久化 → 回傳 DTO
   │   └─ controller/                   # REST Controller / API 實作
   │       └─ UserController.java       # REST Controller
   ├─ service-auth/                     # 登入與憑證服務
   │   ├─ domain/
   │   │   └─ model/AuthCredential.java # 認證憑證（密碼雜湊、狀態、有效期間）
   │   ├─ infra/
   │   │   └─ persistence/
   │   │       ├─ mapper/AuthCredentialMapper.java     # MyBatis Mapper，維護憑證 CRUD
   │   │       └─ repository/AuthCredentialRepository.java # Repository + Impl，供 auth 應用層調用
   │   └─ controller/                   # REST/事件端點實作
   ├─ service-order/                    # 委託與撮合前置服務
   │   ├─ domain/
   │   ├─ infra/
   │   ├─ service/
   │   └─ controller/

```

Service 共用架構守則

- 分層命名統一為 `domain`、`infra`、`service`（或 `app`）、`controller`，使用 DDD 思維維持領域模型與 I/O 隔離。
- 共享功能優先引用 `sdk` 目錄下的共用模組，尤其資料庫、MVC、Security 等現成封裝，避免各服務自行複製設定。
  - 資料庫連線與 MyBatis 由 `sdk-infra-mysql` 自動配置；服務層僅需提供 Mapper XML 與 Repository 介面。
- DTO 與 Entity 映射建議使用 `OpenMapstruct` 等共用工具，減少手寫轉換與重複樣板。
- 契約優先：先設計 OpenAPI / AsyncAPI，並透過 `sdk-contract` 底下的 `exchange-*-sdk` 發佈 SDK 或範本實作。

# 模塊職責


| 模組             | 核心責任                                           |
| ---------------- | -------------------------------------------------- |
| `gateway`        | 對外入口、JWT 驗證、流量治理、觀測性匯出           |
| `auth`           | 登入/權杖/多因子流程、會話管理、登入審計與事件發布 |
| `user`           | 使用者主檔、偏好設定、KYC、角色/權限管理           |
| `account-ledger` | 雙分錄資產台帳、結算、利息/費率計算、報表輸出      |
| `risk-margin`    | 保證金/風險係數計算、下單前限額、強平判斷與佇列    |
| `order`          | 委託下單、撤單、歷史查詢、指令排程、訂單事件溯源   |
| `matching`       | 訂單簿維護、撮合引擎、成交輸出與行情報表來源       |
| `positions`      | 倉位快照、未實現損益、破產價/強平價計算            |
| `market-data`    | 行情快照、K 線/深度資料生成、串流推播服務          |

模組職責詳述

- **gateway**：
  - 對接外部流量，統一執行 JWT 驗證、節流、設備指紋檢查。
  - 管理路由策略、A/B 測試、灰度/Canary 發佈，並整合觀測性管線。
  - 提供健康檢查、錯誤轉換與安全標頭注入。
- **auth**：
  - 支援密碼、OTP、FIDO、社群登入等多種認證方式，維護登入審計。
  - 維護會話、刷新權杖、黑名單、裝置綁定與登入通知。
  - 發布登入/登出事件給風控、報表與通知模組。
- **user**：
  - 維護使用者主檔、偏好設定、語系與通知訂閱，管理 KYC 流程。
  - 管理角色、權限與範圍（scope），提供 RBAC/ABAC 查詢介面。
- **account-ledger**：
  - 以雙分錄維護資產變動，確保借貸平衡並支援審計。
  - 產生結算、利息、資金費率、手續費等財務事件。
- **risk-margin**：
  - 計算保證金與風險指標、提供下單前限額校驗。
  - 維護風控規則版本、建立強平佇列與風險告警。
- **order**：
  - 統一下單入口，支援市價/限價/條件單等多種委託型別。
  - 提供單筆與批次撤單、委託查詢、歷史訂單匯出。
  - 寫入訂單事件（event sourcing）供撮合、報表與重播。

- **matching**：
  - 維護訂單簿、撮合成交、產生成交紀錄與行情報價來源。
  - 將撮合結果推送給 ledger、positions、market-data。
- **positions**：
  - 根據撮合與台帳事件維護倉位、未實現損益、破產價。
  - 觸發強平邏輯並回寫至 risk-margin 與 order 模組。
- **market-data**：
  - 轉換撮合輸出為行情快照、K 線、深度資料和統計指標。
  - 提供 WebSocket / gRPC 串流與快取服務給前端與夥伴。

# 實作順序

- 共用與基座
    - SDK 
    - 事件總線與 Outbox
- 交易主線
    - account-ledger
    - risk-margin
    - order
    - matching
    - positions
    - market-data
    - gateway 路由與權限調整
    - 前端對接
- 收尾與強化
    - 撤銷與權杖黑名單
    - 回放與補償流程
    - 管理與報表
    - 觀測性 日誌 指標 追蹤


# 
# 流程
## 註冊

   - 前端呼叫 `user` 服務的 `POST /api/users`（由 Gateway 轉發）。
   - `user-service` 驗證信箱是否已存在，建立 `User` 主檔，同步在 `user_registration_prepare` 表寫入一筆 `PREPARE` 狀態的註冊工作（包含 userId、email、重試次數等欄位）。
   - 建立成功後呼叫 `auth` 服務，傳入 `AuthCredentialCreateRequest`（帶入 userId、型別、密碼雜湊與鹽值）；`auth` 寫入 `auth_credentials`，並回報成功以更新註冊工作狀態為 `COMPLETED`。
   - 若憑證建立失敗或 `auth` 暫時不可用，`user-service` 會保留 `PREPARE` 狀態並回傳 `RemoteServiceError`，以便稍後重試。
   - **排程補償**：`UserRegistrationResumer`（Spring Scheduling/Quartz Job）每分鐘掃描 `user_registration_prepare`，對停留在 `PREPARE` 的記錄重新呼叫 `auth` 建憑證；成功後標記 `COMPLETED`，連續 N 次失敗則標記 `FAILED` 並發送告警通知營運處理。

## **登入**
   - `POST /api/auth/login`：
	- Gateway 將請求轉給 `auth`。
	- `auth` 依 credential type 讀取 `auth_credentials`，以 `BCrypt`/`Argon2` 驗證密碼並檢查狀態（LOCKED、EXPIRED 等），必要時追加 OTP/FIDO 二次驗證。
	- 驗證成功後寫入 `login_audits`、`auth_sessions`，並在 Redis 建立 `auth:session:{sessionId}`（含 userId、roles、IP、裝置指紋、TTL）。
	- 回傳 Access/Refresh Token，JWT 內含 `sessionId`、`authContext`，供下游服務解析。
   - 請求授權：後續所有 API 由 Gateway 的 JWT Filter 驗證 Access Token，並以 `sessionId` 查詢 Redis（或本地快取）確認會話仍有效；若不存在或標記 `revoked` 即拒絕。
   - Token 續期：Access Token 過期時，前端呼叫 `POST /api/auth/token/refresh`，`auth` 驗證 Refresh Token 是否仍 active，使用樂觀鎖（`refresh_tokens.version`）避免重放，成功則簽發新 Access/Refresh 並延長 Redis session TTL。
   - 登出/失效：`POST /api/auth/logout` 或風控事件會標記 Refresh Token 為 `revoked`、刪除 Redis session，並發布 `AuthSessionRevoked` 事件；Gateway 或服務側可立即終止該會話。
   - 下游使用：各服務的安全 Filter 解析 JWT，將 `OpenJwtUser`（userId、roles、scopes、sessionId）放入 ThreadLocal 或 Reactor Context，支援審計與授權判定。
## 
## 下單


```
Client
  │ 1. 登入 / 權杖刷新（auth）
  │
Gateway
  │ 2. 驗證 JWT、節流、路由
  │
Order ──┐
  │ 3. Order 下單 → Risk-Margin 試算保證金 → Account-Ledger 凍結資金 → Order 建立成功
  │    
  ▼
Matching
  │ 4. 撮合成交 → 將「成交事件」發布至事件匯流排
  │
  ├─▶ Market-Data：公布行情快照 / 深度 / K 線
  ├─▶ Account-Ledger：雙分錄記帳、產生資產事件
  └─▶ Risk-Margin：更新實際成交資訊、調整風險指標

Account-Ledger
  │ 5. 依資產事件更新帳務 → 再發布資產異動事件
  │    └─▶ Positions：同步刷新倉位 / 盈虧 / 破產價

Positions
  │ 6. 更新倉位、市值、未實現損益
  │    └─▶ Risk-Margin：回饋最新風險指標與強平條件

外部消費者（通知 / 報表 / 監控 / BI）
  7. 平行訂閱 Market-Data、Account-Ledger、Positions 事件
```

## Order

```text
Order 下單 → Risk-Margin 試算保證金 → Account-Ledger 凍結資金 → Order 建立成功
```

1. **Risk-Margin 試算
	1. 調用 `risk-margin` 的 `/api/risk/pre-check`。
	- 檢查可用保證金、槓桿倍數、持倉限額。
    - 計算下單所需初始保證金與手續費。
    - 回傳可否下單與所需金額。        
2. **Account-Ledger 凍結**
    - 若試算通過，`order` 應發起 `POST /api/ledger/freeze`：
        - 參數：`userId`, `asset`, `amount`, `referenceType=ORDER`, `referenceId=orderId`
    - `account-ledger` 建立雙分錄：
        - 借：使用者資產帳戶（available → reserved）
        - 貸：系統保證金帳戶
    - 並發出事件 `LedgerEntryCreated(type=FREEZE)`
3. **Order 記錄與發佈**
    - `order` 寫入 `orders` 表後發布 `OrderCreated` 事件。
    - 若後續撮合失敗或撤單，需透過 `account-ledger` 發送 `UNFREEZE` 事件回滾資金。

事件流補充建議

|事件|來源|說明|
|---|---|---|
|`MarginPreCheckPassed`|risk-margin|下單前風控試算通過|
|`FundsFrozen`|account-ledger|保證金凍結完成|
|`OrderCreated`|order|委託建立並進入撮合佇列|
|`OrderCancelled` / `OrderFailed`|order|撤單或失敗時應觸發 `UnfreezeFunds`|
|`UnfreezeFunds`|account-ledger|解凍保證金|

---

若你要保持事件一致性，建議用 **Outbox 模式** 確保凍結與下單事件同時提交，或使用 **分布式 TCC**：
- `Try`：risk-margin 試算 + ledger 預凍結
- `Confirm`：撮合成功 → ledger 確認扣款
- `Cancel`：撤單或撮合失敗 → ledger 解凍
    


## Matching
---

`matching` 是撮合核心，維護每個交易對的訂單簿。  
主要任務是：接收委託事件 → 進入訂單簿 → 配對成交 → 發布成交事件。

#### 訂單接收與掛簿
- 消費 `OrderCreated` 事件。
- 根據 `instrument_id` 取得對應訂單簿。
- 按方向掛入：`BUY` 掛買盤（高價優先），`SELL` 掛賣盤（低價優先）。
- 市價單則立即撮合。
    

#### 撮合規則

|條件|行為|
|---|---|
|buy.price ≥ bestSell.price|成交|
|sell.price ≤ bestBuy.price|成交|
|其他|掛單等待|

撮合演算法：

```
while (對手單存在 && 尚未完全成交):
    tradeQty = min(委託剩餘量, 對手單剩餘量)
    tradePrice = 對手單價格
    生成 TradeExecuted 事件
    更新雙方剩餘量與狀態
    若對手單完成則移出訂單簿
```

#### 成交事件內容

|欄位|說明|
|---|---|
|tradeId|撮合流水號|
|buyOrderId, sellOrderId|雙方委託|
|price, quantity|成交價與數量|
|fee|手續費|
|makerUserId, takerUserId|成交雙方|
|instrumentId|交易對|
|executedAt|成交時間|

---

### 撮合後事件流

`TradeExecuted` 被多模組平行消費：

|模組|處理|
|---|---|
|account-ledger|雙分錄記帳、扣除凍結、計算手續費、發布 `LedgerEntryCreated`|
|positions|更新倉位與平均成本、盈虧|
|risk-margin|更新維持保證金與強平價|
|market-data|推行情快照、成交量、K 線|

---

### 撮合後資金與狀態演進

| 階段    | Order 狀態         | Ledger 動作 | Positions |
| ----- | ---------------- | --------- | --------- |
| 下單    | CREATED          | 凍結保證金     | 無         |
| 撮合中   | PARTIALLY_FILLED | 部分扣款與解凍   | 倉位增加      |
| 撮合完成  | FILLED           | 全部結算與解凍   | 倉位完成更新    |
| 撤單或失敗 | CANCELLED        | 解凍保證金     | 不變        |

---

### 撮合引擎結構建議

```
MatchingEngine
 ├─ OrderBookManager
 │   ├─ Map<InstrumentId, OrderBook>
 │   └─ SnapshotService（定期持久化快照）
 ├─ EventListener
 │   └─ consume(OrderCreated)
 ├─ TradePublisher
 │   └─ publish(TradeExecuted)
 └─ Persistence
     └─ trade_tickers 表 (成交紀錄)
```

---

### 資料一致性與重放
- 撮合結果是唯一真實成交來源。
- `TradeExecuted` 應使用 Kafka exactly-once 模式發布。
- 撮合引擎應保存 WAL（write-ahead log），以便重啟重放。
    

---

### 撮合與撤單交互
- `order-service` 發送 `OrderCancelRequested`。
- `matching` 接收後從訂單簿移除，發布 `OrderCancelled`。
- `account-ledger` 消費後解凍資金，發布 `FundsUnfrozen`。
    

---

### 核心重點
- 撮合主線：OrderCreated → 掛簿 → 撮合 → TradeExecuted → 多模組事件流。
- 凍結與解凍：由 `account-ledger` 控制，保持資金一致性。
- 撮合事件是唯一真實源。
- 高併發下使用 per-instrument 單執行緒模型確保順序與一致性。


## Account-Ledger
「資金結算階段」。 
以下是 `account-ledger` 在撮合成交後收到事件後的**完整內部流程**。

---

### TradeExecuted 事件

來源事件：`TradeExecuted`（由 matching 發布）  

事件內容包括：
- `instrumentId`
- `buyOrderId`, `sellOrderId`
- `price`, `quantity`
- `buyerUserId`, `sellerUserId`
- `fee`
- `executedAt`
    

`account-ledger` 消費這個事件後，開始進行「雙分錄」結算。

---

### 處理目標
- 對買賣雙方進行資金移轉（可用 → 實際結算）
- 扣除或返還凍結資金
- 記錄手續費、盈虧
- 發布新的「資產異動事件」供倉位與風控更新
    

---

### 處理步驟

#### 接收事件

Kafka consumer 收到 `TradeExecuted` → 開啟交易（@Transactional）

---

#### 讀取基礎資料
- 查詢雙方的帳戶餘額 (`ledger_balances`)
- 查詢交易商品參數 (`instrument_metadata`)
- 驗證撮合結果是否已處理過（根據 tradeId 去重，確保冪等）
    

---

#### 計算資金變化

以 BTCUSDT 永續合約為例：

| 角色   | 動作     | 資金方向    | 備註             |
| ---- | ------ | ------- | -------------- |
| 開倉   | 支付成交金額 | 扣除 USDT | 使用凍結保證金結算      |
| 平倉   | 收到成交金額 | 增加 USDT | 結算入帳           |
| 系統帳戶 | 收取手續費  | 增加 USDT | maker/taker 費率 |

---

#### 執行雙分錄記帳

以「借貸必平衡」原則進行三組分錄：

**1. 資金結算**

---

**雙方開倉** 

多方（開多）

```
借：保證金 reserved 減少
貸：持倉 margin_used 增加
```

空方（開空）

```
借：保證金 reserved 減少 
貸：持倉 margin_used 增加
```
→ 二邊都「增加持倉佔用額」，但這是各自帳內的轉換，沒有對方參與。

---

**平倉或強平時才有對向結算**

假設多方平倉時價格高於開倉價（盈利）：

```
借：Short margin_used 減少（虧損方） 
貸：Long margin_used 減少（盈利方） 
貸：Buyer available 增加（實現收益）
```

相反，若多方虧損、空方盈利，方向對調。  
這時才會發生「盈虧轉移」，即從虧損方的保證金扣減，轉給盈利方。


**2. 手續費**

```
借：Buyer or Seller 帳戶（依角色扣費）
貸：Exchange Fee 帳戶（平台收入）
```

**3. 解凍 / 結餘調整**  
若委託未全成交或撤單，將剩餘凍結部分解凍：

```
借：保證金 reserved 減少
貸：保證金 available 增加
```

---

#### 更新餘額表
- `ledger_balances`：更新 balance / available / reserved 欄位。
- `ledger_entries`：插入雙分錄交易明細。  

    欄位示例：
    
    ```
    entry_id, account_id, asset, amount, direction, reference_type='TRADE',
    reference_id=tradeId, event_time=executedAt
    ```
    

---

#### 發布資產異動事件

每筆交易完成後，發出：

```
LedgerEntryCreated {
  userId,
  instrumentId,
  asset,
  deltaAvailable,
  deltaReserved,
  balanceAfter,
  referenceType = TRADE,
  referenceId = tradeId
}
```

供下游模組使用：
- `risk-margin` 更新風險與維持保證金；
- `reporting` 寫入審計或報表。
    

---

#### 提交交易
- 整個過程包在同一個資料庫交易中。
- 成功後提交並確認事件 Outbox → Kafka（確保 exactly-once）。
- 若中途失敗則 rollback，確保資產不亂動。
    

---

### 關鍵要點
- `account-ledger` 是整個系統的**資產真實源**（source of truth）。
- 每個事件皆以**雙分錄**確保會計平衡。
- 結算與發佈事件需使用 Outbox 以保證最終一致性。
- 所有金額欄位需使用 Decimal128 或 BigDecimal 精確運算。
    
## Positions

`positions` 模組負責維護每個用戶在各交易對 (`instrument_id`) 上的**持倉、平均成本、未實現盈虧、強平價、破產價**等資訊。  
它不處理金流，只根據成交與資產事件來更新倉位。  
以下是完整、精準的 `positions` 流程說明。

---

### Positions 模組職責

|類別|功能|
|---|---|
|狀態維護|維護每個用戶在各交易對的倉位方向、數量、均價、未實現損益、強平價|
|事件驅動|消費 `TradeExecuted`、`LedgerEntryCreated`、`MarkPriceUpdated` 等事件來更新倉位與盈虧|
|風險回饋|將更新後的風險指標（margin ratio、liquidation price）發送給 `risk-margin`|
|倉位溯源|維護 `position_events` 表供稽核與重放|

---

### 主資料表

|表名|用途|主要欄位|
|---|---|---|
|`positions`|倉位主檔|`position_id`, `user_id`, `instrument_id`, `side`, `quantity`, `entry_price`, `mark_price`, `unrealized_pnl`, `liquidation_price`, `updated_at`|
|`position_events`|倉位變動紀錄|`event_id`, `position_id`, `event_type`, `delta_qty`, `delta_pnl`, `reference_id`, `occurred_at`|

---

### TradeExecuted 事件處理流程

#### 開倉

當 `matching` 撮合成功發布成交事件後，`positions` 消費它來更新倉位：

##### 步驟
- 查找或建立該用戶 + `instrument_id` + `side` 的倉位記錄。
- 若原倉位不存在 → 建立新倉位。
- 若存在 → 根據成交數量與價格調整平均開倉價與持倉數量。
    

##### 多倉 (Long) 成交邏輯

```
new_qty = old_qty + trade_qty
entry_price = (old_entry_price * old_qty + trade_price * trade_qty) / new_qty
```

##### 空倉 (Short) 成交邏輯

類似，但方向相反，數量為負，盈虧方向顛倒。

##### 倉位更新後
- 從本地 `MarkPriceCache` 取得最新標記價（由 `MarkPriceUpdated` 事件更新）；若暫無資料則保留上一筆標記價，待事件抵達時再刷新。
- 以該標記價暫算未實現盈虧：`unrealized_pnl = (mark_price - entry_price) * qty * contract_size`。
- 計算強平價（根據槓桿與保證金率）。
- 寫入 `positions` 表並新增 `position_events`。
    

---

#### 平倉

來自 `account-ledger` 的資產異動事件，常見用途：
- 撤單 / 解凍保證金 → 更新可用保證金。
- 結算 / 平倉 → 更新倉位數量、實現盈虧。
    

平倉時：
- 根據成交方向更新倉位數量。
- 若 `quantity` 歸零 → 將倉位標記為 `CLOSED` 並釋放記憶體。
- 實現盈虧寫入 `realized_pnl` 並觸發 `PositionClosed` 事件。


---

#### MarkPriceUpdated 事件處理

- `positions` 以 `instrument_id` 為 key 消費 `market.mark-price` topic：
    1. 將標記價寫入本地 `MarkPriceCache`，並記錄事件時間（防止舊價覆蓋新價）。
    2. 查詢所有在該 `instrument_id` 上仍為 `OPEN` 的倉位。
    3. 逐筆重算：

        ```
        unrealized_pnl = (mark_price - entry_price) * position_qty * contract_size
        mark_price_field = mark_price
        ```

    4. 更新 `positions` 表與 `position_events`，僅在盈虧或標記價變化超過閾值（如 notional 0.01%）時落庫，以減少寫入壓力。
    5. 發布 `PositionUpdated` 事件（詳見下節）供風控、報表使用。
- 事件處理與成交事件分開執行，確保行情與倉位計算互不阻塞；若行情延遲，倉位會保留上一次標記價與盈虧。


---

### 內部邏輯狀態轉換

|事件|狀態變化|說明|
|---|---|---|
|開倉成交|`NONE` → `OPEN`|建立新倉位|
|加倉成交|`OPEN` → `OPEN`|增加數量，重算均價|
|減倉（平倉部分）|`OPEN` → `PARTIALLY_CLOSED`|減少數量，部分結算|
|全平|`OPEN` → `CLOSED`|倉位清零，記錄實現盈虧|

---

### 實現與未實現盈虧計算

##### 未實現盈虧（浮動盈虧）

- 公式：

  ```
  unrealized_pnl = (mark_price - entry_price) * position_qty * contract_size
  ```

- `mark_price` 來自最新的 `MarkPriceUpdated` 事件，`entry_price` 為倉位加權成本；`contract_size` 視永續合約面額決定（例：1 USD 或 0.001 BTC）。
- `positions` 會維護 `MarkPriceCache`，事件到達後立即刷新 `mark_price` 與 `unrealized_pnl`，並將結果寫入資料庫與後續事件。
- 多倉：價格上漲 → 盈利；下跌 → 虧損。
- 空倉：價格上漲 → 虧損；下跌 → 盈利（計算時 `position_qty` 為負值，自然反映方向）。


##### 實現盈虧（平倉時）

```
realized_pnl = (close_price - entry_price) * closed_qty
```

更新後：

```
position_qty -= closed_qty
entry_price 保持或重新計算
```

---

### 事件輸出

無論是成交事件還是 `MarkPriceUpdated` 事件造成倉位狀態或盈虧變化，只要超過發布閾值即會發布：

```
PositionUpdated {
  userId,
  instrumentId,
  side,
  quantity,
  entryPrice,
  markPrice,
  unrealizedPnl,
  liquidationPrice,
  timestamp
}
```

消費方：

- **risk-margin**：更新風險係數、強平條件。
    
- **reporting**：寫入歷史與監控系統。
    
- **market-data**（可選）：提供倉位聚合資訊（多空比）。
    

---

### 流程摘要

```
TradeExecuted
  ↓
Positions
  解析成交方向與價格
  更新倉位數量與均價
  以最新標記價暫算未實現損益
  視需要發布 PositionUpdated
  ↓
Risk-Margin / Reporting 消費

MarkPriceUpdated (market.mark-price)
  ↓
Positions
  更新 MarkPriceCache
  重算該標的所有倉位的未實現盈虧與強平價
  發布 PositionUpdated
  ↓
Risk-Margin / Reporting 消費
```

---

### 關鍵特性

- 所有倉位狀態源自成交事件，**不依賴帳務表進行計算**。
    
- 每筆變化寫入 `position_events`，可支援**重放與恢復**。
    
- 倉位更新為**純計算行為，不進行資金轉移**。
    
- 與 `ledger`、`risk` 分層隔離：
    
    - ledger 管金流
        
    - positions 管數量與盈虧
        
    - risk 管安全線與槓桿限制
        

---

簡言之，`positions` 模組是交易引擎的**倉位記錄器**，  
它依據撮合與帳務事件計算每位用戶的持倉與盈虧，  
不動資金、不簽帳，只維護真實狀態與可計算指標，  
並將結果回饋給風控與報表系統形成完整閉環。


## risk-margin

`risk-margin` 模組負責整個交易系統的**風險計算與保證金控制**，  
它連接撮合層與倉位層，是實時監控「每位用戶能否承擔風險」的核心。  
在撮合成交後，`risk-margin` 會根據實際成交與倉位變化動態調整各項風險指標。

以下是完整、工程化的流程說明。

---

### 模組定位

|類別|職責|
|---|---|
|**事前**|下單前預檢（`/api/risk/pre-check`）判斷可否下單、需凍結多少保證金|
|**事中**|撮合成交後更新實際保證金使用與風險指標|
|**事後**|根據持倉與標記價格即時監控槓桿、維持保證金率與強平條件|

---

### 事件驅動流程總覽

`risk-margin` 透過兩類事件驅動運作：

1. **倉位更新事件（`PositionUpdated`）** — 由 `positions` 模組在撮合或調整完成後發布，代表某位用戶的倉位數量、均價等基礎資料已經結算。
2. **行情變動事件（`MarkPriceUpdated` 或 ticker feed）** — 由行情/定價模組發布，攜帶最新標記價格與指標，用於評估當前風險。

兩種事件分別被獨立消費並進行對應處理，最終都會回寫風險指標與狀態。

---

### 消費 `PositionUpdated` 事件的流程

```
PositionUpdated 事件發布
   ↓
Risk-Margin 消費事件
   ↓
依 user/instrument 從 positions 讀取最新倉位
   ↓
計算名義價值與實際保證金佔用
   ↓
更新 risk snapshot、發布 RiskUpdate
```

---

#### 1. 接收倉位更新事件 `PositionUpdated`

Kafka Consumer 收到 `PositionUpdated` 後執行：
- 根據 `instrument_id` 查找對應的 `risk_limits`（初始 / 維持保證金率、最大槓桿）。
- 從事件或 positions 查出對應用戶的倉位基礎資訊（`quantity`、`entry_price` 等）。
- 計算此次倉位調整導致的**保證金佔用變化**與**槓桿變動**。


---

#### 2. 更新實際佔用保證金與槓桿

| 指標               | 計算方式                          | 含義        |
| ---------------- | ----------------------------- | --------- |
| **notional**     | `abs(entry_price * quantity)` | 倉位名義價值    |
| **used_margin**  | `notional / leverage`         | 實際佔用保證金   |
| **margin_ratio** | `(equity / notional)`         | 槓桿比值（風險率） |
`equity` = 淨資產值 =已實現盈虧 + 未實現盈虧 + 餘額


若倉位擴大或槓桿調整：
- 更新該用戶該 `instrument_id` 的 `used_margin`。
- 若超過風控規則（如槓桿上限），標記為 `RISK_ALERT`。


---

#### 3. 從 Positions 拉取最新持倉

風控模組不自己維護倉位數量，它從 `positions` 讀取：

```
quantity, entry_price, mark_price, unrealized_pnl
```

再結合既有的保證金餘額快照計算可用槓桿與風險比率。

---

#### 4. 根據 mark_price 實時計算風險指標

|指標|計算公式|意義|
|---|---|---|
|**unrealized_pnl**|`(mark_price - entry_price) * qty`|未實現盈虧|
|**margin_ratio**|`((margin_balance + unrealized_pnl) / notional)`|維持比率|
|**liquidation_price**|`entry_price * (1 ± (initial_margin - maintenance_margin))`|強平價（多為減，空為加）|

若 `margin_ratio < maintenance_margin_rate`  
→ 觸發強平流程。

---

#### 5. 更新 risk 狀態表與指標快照

寫入或更新：

```
risk_snapshots {
  user_id,
  instrument_id,
  notional_value,
  used_margin,
  equity,
  margin_ratio,
  liquidation_price,
  status,
  updated_at
}
```

狀態可能為：
- `NORMAL`
- `ALERT`（接近維持保證金）
- `MARGIN_CALL`
- `LIQUIDATION_PENDING`
    

---

#### 6. 發布 RiskUpdate 事件

風控結果會以事件形式廣播：

```
RiskUpdate {
  userId,
  instrumentId,
  marginRatio,
  liquidationPrice,
  status,
  timestamp
}
```

消費者：
- **order-service**：若風險過高，暫停新委託。
- **risk-liquidation-worker**：自動強平執行（發起 `liquidation_queue`）。
- **monitor/reporting**：更新風險面板與報表。
    

---

### 消費行情事件的流程

```
MarkPriceUpdated 事件發布
   ↓
Risk-Margin 消費事件
   ↓
帶入既有倉位快照
   ↓
重新計算未實現損益、維持保證金比率與強平價
   ↓
更新 risk snapshot、發布 RiskUpdate / Liquidation 指令
```

行情事件處理的重點在於「即時調整」：每筆標記價格更新都會重新計算倉位風險，即便倉位數量不變，也能在價格急速變動時觸發強平或通知。

---

### 資料流全圖

```
Positions → PositionUpdated
   ↓
Risk-Margin 消費倉位更新 → 更新保證金佔用
   ↓
行情服務 → MarkPriceUpdated
   ↓
Risk-Margin 消費行情變化 → 重新計算維持比率與強平價
   ↓
RiskUpdate 事件 → order / liquidation / dashboard
```

---

### 強平（Liquidation）觸發條件

若：

```
margin_ratio <= maintenance_margin_rate
```

則：
- 寫入 `liquidation_queue`
- 標記倉位為 `LIQUIDATION_PENDING`
- 由強平任務（worker）在下一個 `RiskUpdate` 後讀取佇列，透過平倉委託或直接撮合關閉倉位。
    

---

### 關鍵特性
- **風險指標來源**：以 `positions` 倉位快照與行情標記價為主，搭配風控模組自身維護的保證金餘額快照。
- **mark_price 驅動**：所有風控以標記價為準。
- **事件驅動更新**：不輪詢，而是消費倉位更新與行情推送。
- **即時警戒**：margin_ratio 低於閾值時可主動通知 order-service 禁止加倉。
- **持久化快照**：所有風險變化寫入 `risk_snapshots`，可回放與監控。
    

---

### 總結

在「撮合成交 → 倉位更新 → 行情變動」之後，
`risk-margin` 模組會：

1. 消費 `PositionUpdated` 事件更新保證金佔用。

2. 消費 `MarkPriceUpdated` 事件重新計算維持比率與強平價。

3. 若超標 → 更新狀態、排入強平佇列。

4. 發布 `RiskUpdate` 事件給其他模組。


它是整個交易所風控循環的「實時守門員」。
## Market-Data
`market-data` 模組是整個交易所的**行情引擎與資料分發層**，  
負責從撮合結果 (`TradeExecuted`) 生成並廣播可觀察行情：最新價、成交量、K 線、深度、Funding Rate 等。  
它不參與資金結算，也不直接持倉，只聚焦「市場資訊的生成、儲存與推送」。

以下為完整工程化流程。

---

### 模組職責

| 功能類別     | 說明                                       |
| -------- | ---------------------------------------- |
| **行情生成** | 從 `TradeExecuted` 事件更新最新價、24h 漲跌、成交量、深度等 |
| **行情快照** | 以固定頻率寫入 `market_snapshots`（供 REST 查詢）    |
| **串流分發** | 將即時行情推送至 WebSocket / gRPC stream         |
| **衍生資料** | 產生 K 線、指數價、Funding Rate、標記價等派生資料         |
| **外部訂閱** | 為前端、風控、報表模組提供行情訂閱介面                      |

---

### 事件輸入

#### 1. `TradeExecuted`
- 由 `matching` 模組發出。
- 包含 `instrument_id`, `price`, `quantity`, `side`, `executed_at`。
- 為行情引擎的主要資料來源。
    

#### 2. （可選）`OrderBookUpdated`
- 若撮合引擎有推送完整掛單簿狀態，可用於即時深度更新。
    

---

### 資料處理主流程

```
TradeExecuted
  ↓
Market-Data Consumer
  ↓
更新行情緩存 (in-memory tickers)
  ↓
生成衍生資料 (K線、指數價、Funding rate)
  ↓
更新快照資料庫
  ↓
推送給 WebSocket / gRPC 客戶端
```

---

### 核心處理細節

#### 行情更新

接收到成交後：

```
last_price = trade.price
volume_24h += trade.quantity
turnover_24h += trade.price * trade.quantity
high_24h = max(high_24h, trade.price)
low_24h  = min(low_24h, trade.price)
price_change_24h = (last_price - open_24h) / open_24h
```

結果存入 `ticker_cache[instrument_id]`。

---

#### 深度資料 (Order Book Snapshot)
- 來源：matching 的掛單簿快照或差分。
- 資料結構：
    
    ```
    bids: [(price, qty)...]  # 高→低
    asks: [(price, qty)...]  # 低→高
    ```
- 每次更新後重新計算：
    - 最佳買價 / 賣價 (`best_bid`, `best_ask`)
    - 中間價 (`mid_price = (bid + ask)/2`)
        

---

#### K 線生成
- 每分鐘（或指定周期）將成交聚合為 K 線：
    
    ```
    open, high, low, close, volume
    ```
- 通常由定時任務（Flusher / Stream Processor）從 Kafka 流聚合：
    
    ```
    SELECT
      instrument_id,
      window_start,
      first(price) AS open,
      max(price) AS high,
      min(price) AS low,
      last(price) AS close,
      sum(quantity) AS volume
    FROM TradeExecutedStream
    GROUP BY instrument_id, TUMBLE(window, 1m)
    ```
    

---

#### 生成 Mark Price / Index Price
- 指數價（`index_price`）
    - 依據多個外部現貨交易所的最新成交或加權中間價，使用固定權重或動態權重平均：

      ```
      index_price = \sum_i weight_i * external_price_i
      \text{ where }\sum_i weight_i = 1
      ```

    - 權重來源：市場流動性占比、過去 24h 成交量或可配置權重表。
    - 透過 Sliding Window（如 30s VWAP）平滑尖峰，並對異常報價設置保護（忽略偏離中位數超過 X% 的價格）。
- 標記價（`mark_price`）
    - 以指數價為基礎，調整資金費率與現貨/期貨價差形成的溢價指數：

      ```
      premium_index = clamp\left(\frac{fair_price - index_price}{index_price},\ -0.05\%,\ 0.05\%\right)
      funding_basis = clamp(interest_rate_diff,\ -0.05\%,\ 0.05\%)
      mark_price = index_price * \left(1 + clamp(premium_index + funding_basis,\ -0.5\%,\ 0.5\%)\right)
      ```

    - `fair_price` 可取撮合最新成交價與買賣盤中間價的加權平均，用以反映期貨市場價格。
    - 透過指數價與標記價雙緩衝，避免單一異常成交引發大規模爆倉。
- 事件發布
    - 每次指數價/標記價更新後，以 `MarkPriceUpdated` 事件（Kafka topic: `market.mark-price`) 廣播：

      ```json
      {
        "instrumentId": "BTCUSDT-PERP",
        "indexPrice": 64000.12,
        "markPrice": 63980.45,
        "fairPrice": 63975.60,
        "premiumIndex": -0.0003,
        "fundingBasis": 0.0001,
        "calculatedAt": "2024-05-07T10:15:30.000Z"
      }
      ```

    - 消費方：
        - `positions`：以最新 `mark_price` 更新倉位浮動盈虧。
        - `risk-margin`：重新評估維持保證金率與強平價。
        - 其他（如報表、監控）可選擇消費以建立指數價歷史。
        
---

#### 生成 Funding Rate
- 定期（8h 或 1h）計算：
    
    ```
    funding_rate = clamp(premium_index + clamp(interest_rate_diff, -0.05%, 0.05%), -0.75%, +0.75%)
    funding_fee = position_notional * funding_rate
    ```
- 發布事件：
    
    ```
    FundingRateUpdated { instrumentId, rate, effectiveAt }
    ```
- 寫入 `funding_rates` 表。
    

---

### 快照儲存

將 in-memory 行情以固定頻率 flush 到資料庫：

```
market_snapshots (
  snapshot_id,
  instrument_id,
  last_price,
  volume_24h,
  bid_depth,
  ask_depth,
  captured_at
)
```

供 REST API 查詢：

```
GET /api/market/tickers/{instrumentId}
GET /api/market/kline?symbol=BTCUSDT&period=1m
```

---

### 串流推送

WebSocket 頻道範例：

```
/ws/market
  ├─ /tickers
  ├─ /depth
  ├─ /trades
  ├─ /kline
```

推送格式：

```json
{
  "type": "ticker",
  "symbol": "BTCUSDT",
  "last": 64200.5,
  "change24h": 2.31,
  "volume": 11345.8,
  "high": 65000,
  "low": 62500,
  "timestamp": 1730982000000
}
```

---

### 模組內部結構建議

```
MarketDataService
 ├─ TickerCache          # 實時最新價與24h統計
 ├─ DepthCache           # 掛單簿快照
 ├─ KlineAggregator      # K線聚合器
 ├─ IndexPriceService    # 指數/標記價計算
 ├─ FundingRateService   # 資金費率計算
 ├─ SnapshotWriter       # 週期性持久化
 └─ WebSocketBroadcaster # 行情推送
```

---

### 與其他模組的互動

|模組|方向|說明|
|---|---|---|
|**matching**|←|提供撮合成交與掛單簿變化|
|**positions**|→|提供 mark_price 更新事件|
|**risk-margin**|→|用於風險計算、強平判斷|
|**gateway**|→|統一轉發給前端客戶端|
|**reporting / BI**|→|提供歷史行情與統計查詢|

---

### 關鍵特性
- **事件驅動**：核心資料皆源自 `TradeExecuted`，確保一致性。
- **多層快取**：記憶體快取 + Kafka Stream + 週期快照。
- **防操縱邏輯**：mark_price 與 index_price 分離，防止瞬間成交價觸發強平。
- **低延遲設計**：行情計算與推送走 in-memory，延遲可壓至 <10ms。
- **一致性保障**：所有派生資料均可由原始成交流重放生成。
    

---

### 總結

`market-data` 模組流程簡述：

```
TradeExecuted
  ↓
更新即時行情與深度
  ↓
聚合生成 K 線 / 指數價 / 資金費率
  ↓
寫入 market_snapshots
  ↓
推送 WebSocket 與發布 MarkPriceUpdated
  ↓
positions / risk-margin 消費更新
```

它是整個交易系統的「行情心臟」，  
負責把撮合結果轉化為市場資訊，驅動用戶端畫面、風控與倉位估值。


## 
## 查詢委託、倉位、行情

前端可透過 Gateway 查詢委託、倉位；並從 `market-data` WebSocket 接收實時行情。

# 接口

## gateway

## user
- `POST /api/users`：註冊
- `GET /api/users/me`：查詢基本資料。

## auth

- `POST /api/auth/credentials`：建立憑證
- 下述 REST 端點由 `sdk-auth-server` 提供預設實作；服務引入該模組後即可直接啟用。
	- `POST /api/auth/login`：驗證憑證 → 簽發 Access/Refresh Token，同時在 Redis 建立 session（`sessionId`、`userId`、到期時間等）。
	- `POST /api/auth/token/refresh`：使用 Refresh Token 取得新的 Access Token，並延長 Redis session 到期時間。
	- `POST /api/auth/logout`：作廢 Refresh Token/Session（刪除 Redis session）。
- Event Output：`AuthSessionRevoked`（強制登出或風險事件時發布，Gateway/周邊可中止會話）。
## account-ledger

- Event Input：`TradeExecuted`（記帳）。
- Event Output：`LedgerEntryCreated`（資產異動事件）。
- `GET /api/ledger/balances?userId=`：查詢餘額/可用資金（供前端或風控使用）。
## risk-margin

- `POST /api/risk/pre-check`：依用戶、委託金額、倉位資料返回是否允許下單。
- Event Input：`TradeExecuted`、`PositionUpdated`（更新風險指標）。
- Event Output：`RiskUpdate`（風險調整回饋給 order 或其他模組）。
## order

- `POST /api/orders`：建立委託（限價/市價/買賣方向）。
- `DELETE /api/orders/{orderId}`：撤銷委託。
- `GET /api/orders/{orderId}`：查詢委託狀態與細節。
- Event：`OrderCreated`、`OrderCancelled` 發布到事件匯流排。

## matching

- Event Input：`OrderCreated`（掛單/撮合）。
- Event Output：`TradeExecuted`（成交事件，含價格/數量/對手單/手續費等）。
- （可選）`POST /api/matching/cancel`：撮合層執行撤單。



## positions

- Event Input：`LedgerEntryCreated`、`TradeExecuted`。
- Event Output：`PositionUpdated`（倉位、市值、未實現損益）。
- `GET /api/positions?userId=`：查詢當前倉位與損益。

## market-data

- Event Input：`TradeExecuted`、撮合深度快照。
- WebSocket `GET /ws/market`：推送行情、成交、K 線資料。
- REST `GET /api/market/tickers/{instrumentId}`：提供最新行情資訊。

# 表結構

auth 模組


| 表名                | 用途           | 主要欄位                                                                                           | 備註                                   |
| ------------------- | -------------- | -------------------------------------------------------------------------------------------------- | -------------------------------------- |
| `auth_credentials`* | 登入憑證資料   | `id (PK)`, `user_id`, `credential_type`, `secret_hash`, `salt`, `status`, `expires_at`             | 支援密碼、API Key、FIDO 等多元憑證。   |
| `auth_providers`    | 第三方登入綁定 | `id (PK)`, `user_id`, `provider`, `provider_user_id`, `linked_at`                                  | 儲存社群/外部身份對應。                |
| `refresh_tokens`    | JWT 會話持久化 | `token_id (PK)`, `user_id`, `session_id`, `issued_at`, `expires_at`, `is_active`, `revoked_reason` | 搭配權杖刷新、強制登出與風險登入鎖定。 |
| `login_audits`      | 登入審計記錄   | `id (PK)`, `user_id`, `ip`, `user_agent`, `result`, `failure_reason`, `logged_at`                  | 供風控、合規、行為分析使用。           |

user 模組


| 表名                       | 用途          | 主要欄位                                                                                 | 備註                                |
| -------------------------- | ------------- | ---------------------------------------------------------------------------------------- | ----------------------------------- |
| `users`*                   | 使用者主檔    | `id (PK)`, `external_id`, `email`, `status`, `created_at`, `updated_at`                  | 其他資料表以`user_id` 外鍵串聯。    |
| `user_profiles`            | 個資與偏好    | `user_id (PK/FK users)`, `display_name`, `country`, `language`, `timezone`               | 與`users` 1:1，儲存顯示與通知設定。 |
| `kyc_records`              | 身分驗證紀錄  | `id (PK)`, `user_id`, `tier`, `status`, `submitted_at`, `approved_at`, `rejected_reason` | 支援多次送審與審核歷程。            |
| `role_assignments`         | 角色/權限授權 | `id (PK)`, `user_id`, `role`, `scope`, `granted_by`, `granted_at`, `expires_at`          | RBAC 核心資料表。                   |
| `notification_preferences` | 通知訂閱設定  | `id (PK)`, `user_id`, `channel`, `is_enabled`, `updated_at`                              | 控制 Email、SMS、Push 等通路。      |

order 模組


| 表名           | 用途         | 主要欄位                                                                                                                                                   | 備註                           |
| -------------- | ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ |
| `orders`*      | 委託主檔     | `order_id (PK)`, `user_id`, `instrument_id`, `client_order_id`, `side`, `type`, `price`, `quantity`, `status`, `time_in_force`, `created_at`, `updated_at` | 委託生命週期的核心資料。       |
| `order_events` | 委託事件溯源 | `event_id (PK)`, `order_id`, `event_type`, `payload`, `occurred_at`, `actor`                                                                               | 支援重播、稽核與行為分析。     |
| `order_tasks`  | 異步指令佇列 | `task_id (PK)`, `order_id`, `task_type`, `payload`, `status`, `retry_count`, `scheduled_at`                                                                | 批次撤單、策略單等非即時動作。 |

matching 模組


| 表名               | 用途   | 主要欄位                                                                                            | 備註             |
| ---------------- | ---- | ----------------------------------------------------------------------------------------------- | -------------- |
| `trade_tickers`* | 成交紀錄 | `trade_id (PK)`, `order_id`, `counterparty_order_id`, `price`, `quantity`, `fee`, `executed_at` | 撮合輸出，供報表與事件回放。 |

account-ledger 模組


| 表名              | 用途       | 主要欄位                                                                                                      | 備註                     |
| ----------------- | ---------- | ------------------------------------------------------------------------------------------------------------- | ------------------------ |
| `ledger_entries`* | 雙分錄紀錄 | `entry_id (PK)`, `account_id`, `asset`, `amount`, `direction`, `reference_type`, `reference_id`, `event_time` | 借貸必須平衡，支援審計。 |
| `ledger_balances` | 帳戶餘額   | `id (PK)`, `account_id`, `asset`, `balance`, `available`, `reserved`, `updated_at`                            | 提供資產查詢與風控試算。 |
| `funding_rates`   | 資金費率   | `id (PK)`, `instrument_id`, `rate`, `effective_at`, `calculated_at`                                           | 供費率結算與倉位估值。   |

risk-margin 模組


| 表名                | 用途     | 主要欄位                                                                                                           | 備註                         |
| ------------------- | -------- | ------------------------------------------------------------------------------------------------------------------ | ---------------------------- |
| `risk_limits`       | 風控參數 | `id (PK)`, `instrument_id`, `tier`, `initial_margin_rate`, `maintenance_margin_rate`, `max_leverage`, `updated_at` | 下單前保證金與限額判斷依據。 |
| `liquidation_queue` | 強平佇列 | `id (PK)`, `position_id`, `status`, `queued_at`, `processed_at`, `reason`                                          | 追蹤強平排程與處理狀態。     |

positions 模組


| 表名              | 用途         | 主要欄位                                                                                                                                             | 備註                     |
| ----------------- | ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ |
| `positions`*      | 倉位主檔     | `position_id (PK)`, `user_id`, `instrument_id`, `side`, `quantity`, `entry_price`, `mark_price`, `unrealized_pnl`, `liquidation_price`, `updated_at` | 倉位快照與估值資料。     |
| `position_events` | 倉位事件溯源 | `event_id (PK)`, `position_id`, `event_type`, `delta_qty`, `delta_pnl`, `reference_id`, `occurred_at`                                                | 追蹤倉位變化與強平歷程。 |

market-data 模組


| 表名               | 用途     | 主要欄位                                                                                                 | 備註                     |
| ------------------ | -------- | -------------------------------------------------------------------------------------------------------- | ------------------------ |
| `market_snapshots` | 行情快照 | `snapshot_id (PK)`, `instrument_id`, `bid_depth`, `ask_depth`, `last_price`, `volume_24h`, `captured_at` | 提供行情查詢與串流基礎。 |

共用參數


| 表名                  | 用途         | 主要欄位                                                                                                    | 備註                           |
| --------------------- | ------------ | ----------------------------------------------------------------------------------------------------------- | ------------------------------ |
| `instrument_metadata` | 交易商品設定 | `instrument_id (PK)`, `symbol`, `base_asset`, `quote_asset`, `status`, `tick_size`, `lot_size`, `launch_at` | 供所有交易模組共用的靜態資訊。 |

> 後續若擴充期權、現貨或策略單，可依各模組需求延伸專屬資料表與事件流，並沿用上述設計原則。

# 其他

協定
- **外部 API**：以 OpenAPI 管理 REST 契約；行情推送以 WebSocket 為主，後續可擴充 gRPC stream。
- **內部事件**：以 Kafka 為主要匯流，訊息以json格式方便開發。

資料一致性、模型、數據分析

- **業務鍵**：所有轉賬／撤銷皆使用全球唯一業務鍵，支援冪等與重放。
- **賬本**：使用關係型資料庫維護不可變雙分錄表，以事件溯源確保追蹤性。
- **撮合狀態**：採內存訂單簿 + 定期快照 + WAL 備援，依交易對分片擴充。
- **分析側**：事件流計畫匯入 ClickHouse/Elasticsearch，支援即時報表與回溯分析。

安全與合規

- **身份與授權**：規劃導入 OIDC 與多因子驗證，敏感操作需完整審計與審批流程。
- **風險控制**：在 Gateway 與風控服務導入節流、簽名與爆倉保護；策略使用配置化管理。
- **資產安全**：賬本服務保留審計軌跡，錢包/HSM 整合待錢包服務完成後納入。
- **合規報表**：透過賬本與事件流提供對帳、監管報表所需資料。

持續優化

- 擴充壓測與撮合回放資料，驗證極端行情下的性能與穩定性。
- 規劃資金費率、強平與錢包模組，並完善對應的事件流與監控。
